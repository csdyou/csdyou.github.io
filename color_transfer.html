<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>影像色彩風格轉換器 (JavaScript版)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #1a73e8;
        }
        .container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-bottom: 20px;
        }
        .box {
            flex: 1;
            padding: 15px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            text-align: center;
        }
        canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:disabled {
            background-color: #9e9e9e;
            cursor: not-allowed;
        }
        button:hover:not(:disabled) {
            background-color: #155ab6;
        }
        #status {
            text-align: center;
            font-size: 18px;
            color: #d9534f;
            min-height: 25px;
        }
    </style>
</head>
<body>

    <h1>🎨 影像色彩風格轉換器 (JavaScript版)</h1>

    <div class="container">
        <div class="box">
            <h2>來源圖片 (Source)</h2>
            <input type="file" id="sourceFile" accept="image/*">
            <canvas id="sourceCanvas"></canvas>
        </div>
        <div class="box">
            <h2>風格參考 (Reference)</h2>
            <input type="file" id="refFile" accept="image/*">
            <canvas id="refCanvas"></canvas>
        </div>
    </div>

    <div class="controls">
        <button id="transferBtn" disabled>開始轉換</button>
    </div>

    <p id="status"></p>

    <div class="container">
        <div class="box" style="flex: 1.5;">
            <h2>轉換結果</h2>
            <canvas id="resultCanvas"></canvas>
        </div>
    </div>

    <script>
        // DOM 元素
        const sourceFileInput = document.getElementById('sourceFile');
        const refFileInput = document.getElementById('refFile');
        const transferBtn = document.getElementById('transferBtn');
        const statusEl = document.getElementById('status');
        
        const sourceCanvas = document.getElementById('sourceCanvas');
        const refCanvas = document.getElementById('refCanvas');
        const resultCanvas = document.getElementById('resultCanvas');
        
        const sourceCtx = sourceCanvas.getContext('2d');
        const refCtx = refCanvas.getContext('2d');
        const resultCtx = resultCanvas.getContext('2d');

        let sourceImageLoaded = false;
        let refImageLoaded = false;

        // 監聽檔案上傳
        sourceFileInput.addEventListener('change', (e) => loadImage(e.target.files[0], sourceCanvas, 'source'));
        refFileInput.addEventListener('change', (e) => loadImage(e.target.files[0], refCanvas, 'reference'));
        transferBtn.addEventListener('click', startColorTransfer);
        
        function loadImage(file, canvas, type) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    if (type === 'source') sourceImageLoaded = true;
                    if (type === 'reference') refImageLoaded = true;
                    checkImagesLoaded();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function checkImagesLoaded() {
            if (sourceImageLoaded && refImageLoaded) {
                transferBtn.disabled = false;
            }
        }

        function startColorTransfer() {
            statusEl.textContent = '正在讀取像素資料...';
            transferBtn.disabled = true;

            // 確保參考圖像的尺寸與來源圖像一致，以進行像素級統計
            const tempRefCanvas = document.createElement('canvas');
            tempRefCanvas.width = sourceCanvas.width;
            tempRefCanvas.height = sourceCanvas.height;
            const tempRefCtx = tempRefCanvas.getContext('2d');
            tempRefCtx.drawImage(refCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height);
            
            // 使用 setTimeout 讓 UI 更新，避免瀏覽器卡死
            setTimeout(() => {
                const sourceData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
                const refData = tempRefCtx.getImageData(0, 0, tempRefCanvas.width, tempRefCanvas.height);

                statusEl.textContent = '正在轉換色彩空間 (RGB -> LAB)...';
                setTimeout(() => {
                    const sourceLab = rgbaToLab(sourceData.data);
                    const refLab = rgbaToLab(refData.data);
                    
                    statusEl.textContent = '正在計算統計數據...';
                    setTimeout(() => {
                        const sourceStats = calculateStats(sourceLab);
                        const refStats = calculateStats(refLab);
                        
                        statusEl.textContent = '正在應用色彩轉換...';
                        setTimeout(() => {
                            const resultLab = applyTransfer(sourceLab, sourceStats, refStats);
                            
                            statusEl.textContent = '正在轉換回 RGB 色彩空間...';
                            setTimeout(() => {
                                const resultRgba = labToRgba(resultLab);
                                
                                statusEl.textContent = '正在繪製結果...';
                                setTimeout(() => {
                                    resultCanvas.width = sourceCanvas.width;
                                    resultCanvas.height = sourceCanvas.height;
                                    const resultImageData = new ImageData(new Uint8ClampedArray(resultRgba), sourceCanvas.width, sourceCanvas.height);
                                    resultCtx.putImageData(resultImageData, 0, 0);
                                    statusEl.textContent = '轉換完成！';
                                    transferBtn.disabled = false;
                                }, 10);
                            }, 10);
                        }, 10);
                    }, 10);
                }, 10);
            }, 10);
        }

        // --- 核心演算法 ---

        function rgbaToLab(rgba) {
            const lab = new Float32Array(rgba.length / 4 * 3);
            for (let i = 0, j = 0; i < rgba.length; i += 4, j += 3) {
                // 1. RGB [0, 255] -> [0, 1]
                let r = rgba[i] / 255;
                let g = rgba[i + 1] / 255;
                let b = rgba[i + 2] / 255;

                // 2. Gamma correction
                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                // 3. RGB to XYZ
                let x = r * 0.4124 + g * 0.3576 + b * 0.1805;
                let y = r * 0.2126 + g * 0.7152 + b * 0.0722;
                let z = r * 0.0193 + g * 0.1192 + b * 0.9505;

                // 4. XYZ to LAB
                x /= 0.95047;
                y /= 1.00000;
                z /= 1.08883;

                x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

                lab[j] = (116 * y) - 16;
                lab[j + 1] = 500 * (x - y);
                lab[j + 2] = 200 * (y - z);
            }
            return lab;
        }

        function calculateStats(lab) {
            const n = lab.length / 3;
            let sumL = 0, sumA = 0, sumB = 0;

            for (let i = 0; i < lab.length; i += 3) {
                sumL += lab[i];
                sumA += lab[i + 1];
                sumB += lab[i + 2];
            }
            const mean = [sumL / n, sumA / n, sumB / n];

            let sumSqDiffL = 0, sumSqDiffA = 0, sumSqDiffB = 0;
            for (let i = 0; i < lab.length; i += 3) {
                sumSqDiffL += Math.pow(lab[i] - mean[0], 2);
                sumSqDiffA += Math.pow(lab[i + 1] - mean[1], 2);
                sumSqDiffB += Math.pow(lab[i + 2] - mean[2], 2);
            }
            const std = [
                Math.sqrt(sumSqDiffL / n) || 1, // Avoid division by zero
                Math.sqrt(sumSqDiffA / n) || 1,
                Math.sqrt(sumSqDiffB / n) || 1
            ];
            
            return { mean, std };
        }

        function applyTransfer(sourceLab, sourceStats, refStats) {
            const resultLab = new Float32Array(sourceLab.length);
            const scale = [
                refStats.std[0] / sourceStats.std[0],
                refStats.std[1] / sourceStats.std[1],
                refStats.std[2] / sourceStats.std[2]
            ];

            for (let i = 0; i < sourceLab.length; i += 3) {
                resultLab[i] = (sourceLab[i] - sourceStats.mean[0]) * scale[0] + refStats.mean[0];
                resultLab[i + 1] = (sourceLab[i + 1] - sourceStats.mean[1]) * scale[1] + refStats.mean[1];
                resultLab[i + 2] = (sourceLab[i + 2] - sourceStats.mean[2]) * scale[2] + refStats.mean[2];
            }
            return resultLab;
        }

        function labToRgba(lab) {
            const rgba = new Uint8ClampedArray(lab.length / 3 * 4);
            for (let i = 0, j = 0; i < lab.length; i += 3, j += 4) {
                let l = lab[i];
                let a = lab[i + 1];
                let b = lab[i + 2];
                
                // 1. LAB to XYZ
                let y = (l + 16) / 116;
                let x = a / 500 + y;
                let z = y - b / 200;

                x = Math.pow(x, 3) > 0.008856 ? Math.pow(x, 3) : (x - 16 / 116) / 7.787;
                y = Math.pow(y, 3) > 0.008856 ? Math.pow(y, 3) : (y - 16 / 116) / 7.787;
                z = Math.pow(z, 3) > 0.008856 ? Math.pow(z, 3) : (z - 16 / 116) / 7.787;

                x *= 0.95047;
                y *= 1.00000;
                z *= 1.08883;

                // 2. XYZ to RGB
                let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
                let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
                let bl = x * 0.0557 + y * -0.2040 + z * 1.0570;

                // 3. Gamma correction
                r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;
                g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;
                bl = bl > 0.0031308 ? 1.055 * Math.pow(bl, 1 / 2.4) - 0.055 : 12.92 * bl;

                // 4. Clip and scale to [0, 255]
                rgba[j] = Math.max(0, Math.min(255, r * 255));
                rgba[j + 1] = Math.max(0, Math.min(255, g * 255));
                rgba[j + 2] = Math.max(0, Math.min(255, bl * 255));
                rgba[j + 3] = 255; // Alpha channel
            }
            return rgba;
        }

    </script>
</body>
</html>